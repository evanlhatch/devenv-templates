#!/usr/bin/env bash\nset -euo pipefail\n\n# --- Configuration & Helper Functions ---\n# (Similar to the previous version of init-project.sh with log_info, log_error, usage)\n# Key change: Determine FLAKE_ROOT dynamically assuming this script is run from the flake context\n# Or, if `nix run` unpacks the flake, we need to locate the template directories differently.\n# For `nix run`, the script is often put into a temp location.\n# A robust way is to have the flake output the paths to the template directories,\n# and the script (or a wrapper) consumes these.\n# Given the setup with `packages.init-script-env`, the script is in the Nix store.\n# The source files (templates) are also in the Nix store, referenced by `self`.\n# The easiest way if writeShellScriptBin copies the script is to have the flake\n# pass the paths to the templates *into* the script text itself during generation.\n\n# This script will be wrapped by `pkgs.writeShellScriptBin` and paths to templates\n# will be interpolated directly by Nix. We achieve this by having the `program`\n# attribute in `flake.nix` use `pkgs.substituteAll` or by embedding paths\n# directly if `self` is accessible.\n# For now, let\'s assume the Flake\'s `program` attribute will handle path interpolation.\n# The version of init-project.sh from the previous \"Flake app\" response is a good base.\n# I will paste that here and highlight key areas to ensure they work with this structure.\n\n# This script is intended to be wrapped by `pkgs.writeShellScriptBin`\n# where `templateBasePath`, `templatePythonPath`, `templateRustPath`,\n# `inputsNixpkgsUrl`, `inputsDevenvUrl`, etc. are substituted by Nix.\n\n# Example of how it might be called by pkgs.writeShellScriptBin with pkgs.substituteAll\n# program = pkgs.substituteAll {\n#   src = ./init-project.sh;\n#   sd = pkgs.sd;\n#   coreutils = pkgs.coreutils;\n#   gnugrep = pkgs.gnugrep;\n#   findutils = pkgs.findutils;\n#   git = pkgs.git;\n#   bash = pkgs.bash;\n#   isExecutable = true;\n#   template_base_path = \"${self}/template_base\";\n#   template_python_path = \"${self}/template_python\";\n#   template_rust_path = \"${self}/template_rust\";\n#   inputs_nixpkgs_url = inputs.nixpkgs.url;\n#   inputs_devenv_url = inputs.devenv-sh.url;\n#   inputs_flake_utils_url = inputs.flake-utils.url;\n#   inputs_uv2nix_url = inputs.uv2nix.url;\n#   inputs_uv2nix_rev = inputs.uv2nix.rev;\n#   # inputs_ty_source_url = inputs.ty-source.url; # Removed\n#   inputs_crane_url = inputs.crane.url;\n#   inputs_fenix_url = inputs.fenix.url;\n#   generated_project_config_path = generatedProjectConfig; # Path to Nix-generated config\n# };\n\n# --- Configuration ---\nDEFAULT_PYTHON_VERSION=\"3.11\"\nDEFAULT_MANAGE_DEPS_WITH_UV2NIX=\"false\"\nDEFAULT_RUST_EDITION=\"2021\" # Or \"2024\" if applicable\n\n# Path to sd, coreutils, etc., will be available via PATH from the buildEnv\n# The template paths will be substituted by Nix when the script is built\nreadonly BASE_TEMPLATE_DIR=\"@template_base_path@\"\nreadonly PYTHON_TEMPLATE_DIR=\"@template_python_path@\"\nreadonly RUST_TEMPLATE_DIR=\"@template_rust_path@\"\n\n# --- Helper Functions ---\nlog_info() {\n  echo \"INFO: $1\"\n}\nlog_error() {\n  echo \"ERROR: $1\" >&2\n  exit 1\n}\n\n# --- Argument Parsing ---\n# (Same argument parsing as before: $1=PROJECT_TYPE, $2=PROJECT_NAME, then key=value pairs)\nif [ \"$#\" -lt 2 ]; then\n  echo \"Usage: $0 <project-type> <project-name> [python-version=X.Y] [manage-deps-with-uv2nix=true|false] [rust-edition=2021|2024]\"\n  echo \"Example (Python): $0 python my-python-app python-version=3.11 manage-deps-with-uv2nix=true\"\n  echo \"Example (Rust):   $0 rust my-rust-app rust-edition=2021\"\n  exit 1\nfi\n\nPROJECT_TYPE=$1\nPROJECT_DIR_NAME=$2 # This can be a relative or absolute path\nPROJECT_NAME=$(basename \"$PROJECT_DIR_NAME\")\nshift 2\n\nPYTHON_VERSION=$DEFAULT_PYTHON_VERSION\nMANAGE_DEPS_WITH_UV2NIX=$DEFAULT_MANAGE_DEPS_WITH_UV2NIX\nRUST_EDITION=$DEFAULT_RUST_EDITION\n\nfor arg in \"$@\"; do\n  case $arg in\n    python-version=*)\n      PYTHON_VERSION=\"${arg#*=}\"\n      ;;\n    manage-deps-with-uv2nix=*)\n      MANAGE_DEPS_WITH_UV2NIX=\"${arg#*=}\"\n      ;;\n    rust-edition=*)\n      RUST_EDITION=\"${arg#*=}\"\n      ;;\n    *)\n      log_error \"Unknown argument: $arg\"\n      ;;\n  esac\ndone\n\nTARGET_DIR=\"$PROJECT_DIR_NAME\" # Use the provided name directly\n\nlog_info \"Project Type: ${PROJECT_TYPE}\"\nlog_info \"Project Name: ${PROJECT_NAME}\"\nlog_info \"Target Directory: ${TARGET_DIR}\"\n# ... (Log Python/Rust specific chosen versions)\n\n# --- Safety Check & Setup ---\nif [ -d \"$TARGET_DIR\" ]; then\n  read -r -p \"Directory ${TARGET_DIR} already exists. Overwrite? (y/N): \" confirmation\n  if [[ \"$confirmation\" != \"y\" && \"$confirmation\" != \"Y\" ]]; then\n    log_info \"Aborted.\"\n    exit 0\n  fi\n  log_info \"Removing existing directory: ${TARGET_DIR}\"\n  rm -rf \"${TARGET_DIR}\"\nfi\nmkdir -p \"$TARGET_DIR\"\n# cd \"$TARGET_DIR\" # Not strictly needed here, operations use $TARGET_DIR path\n\n# --- Copy Files & Create Configs ---\nlog_info \"Copying base template files to ${TARGET_DIR}...\"\ncp -rT \"$BASE_TEMPLATE_DIR/\" \"$TARGET_DIR/\" # -T treats source as a directory\nmv \"${TARGET_DIR}/.gitignore_template\" \"${TARGET_DIR}/.gitignore\"\nmv \"${TARGET_DIR}/justfile_template\" \"${TARGET_DIR}/Justfile\"\nmv \"${TARGET_DIR}/README.md_template\" \"${TARGET_DIR}/README.md\"\nif [ -f \"${TARGET_DIR}/project_config.nix_template\" ]; then\n  rm \"${TARGET_DIR}/project_config.nix_template\"\nfi \n\n# 1. Copy pre-generated project_config.nix from flake\nlog_info \"Copying pre-generated project_config.nix template...\"\ncp \"@generated_project_config_path@\" \"${TARGET_DIR}/project_config.nix\"\nlog_info \"Copied project_config.nix template.\"\n\n# 2. Create devenv.yaml with pinned inputs from the template flake\nlog_info \"Creating devenv.yaml...\"\ncat << EOF > \"${TARGET_DIR}/devenv.yaml\"\n# This file pins inputs for devenv.sh if not using a project flake for this.\n# It\'s less critical if the generated project flake.nix pins these.\ninputs:\n  nixpkgs:\n    url: @inputs_nixpkgs_url@\nEOF\n\n# 3. Create .envrc for direnv + Flakes\nlog_info \"Creating .envrc...\"\ncat << EOF > \"${TARGET_DIR}/.envrc\"\n# For nix-direnv to load the flake environment automatically\n# Ensures all developers use the same consistent shell.\nuse flake . --no-pure-eval\nEOF\n\n# 4. Create the main project flake.nix (based on a simple template)\nlog_info \"Creating project flake.nix...\"\n\nPYTHON_INPUTS=\"\"\nif [ \"$PROJECT_TYPE\" == \"python\" ]; then\n  PYTHON_INPUTS=$(echo \\\n\"    uv2nix = {\\\\n      url = \\\"@inputs_uv2nix_url@\\\";\\\\n      rev = \\\"@inputs_uv2nix_rev@\\\";\\\\n      inputs.nixpkgs.follows = \\\"nixpkgs\\\";\\\\n    };\")\nfi\n\nRUST_INPUTS=\"\"\nif [ \"$PROJECT_TYPE\" == \"rust\" ]; then\n  RUST_INPUTS=$(echo \\\n\"    crane.url = \\\"@inputs_crane_url@\\\";\\\\n      crane.inputs.nixpkgs.follows = \\\"nixpkgs\\\";\\\\n    fenix.url = \\\"@inputs_fenix_url@\\\";\\\\n      fenix.inputs.nixpkgs.follows = \\\"nixpkgs\\\";\")\nfi\n\ncat << EOF > \"${TARGET_DIR}/flake.nix\"\n{\n  description = \"A new ${PROJECT_TYPE} project: ${PROJECT_NAME}\";\n\n  inputs = {\n    nixpkgs.url = \"@inputs_nixpkgs_url@\";\n    flake-utils.url = \"@inputs_flake_utils_url@\";\n    devenv-sh.url = \"@inputs_devenv_url@\";\n    devenv-sh.inputs.nixpkgs.follows = \"nixpkgs\";\n\n${PYTHON_INPUTS}\n${RUST_INPUTS}\n  };\n\n  nixConfig = {\n    extra-trusted-public-keys = \"devenv.cachix.org-1:w1cLUi8dv3hnoSPGAuibQv+f9TZLr6cv/Hm9XgU50cw=\";\n    extra-substituters = \"https://devenv.cachix.org\";\n  };\n\n  outputs = { self, nixpkgs, devenv-sh, flake-utils, ... }@inputs:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = import nixpkgs {\n          inherit system;\n          config.allowUnfree = true;\n        };\n      in\n      {\n        devShells.default = devenv-sh.lib.mkFlake {\n          inherit pkgs inputs;\n        };\n      }\n    );\n}\nEOF\n\n# --- Language-Specific File Copying & Setup ---\nif [ \"\\$PROJECT_TYPE\" == \"python\" ]; then\n  log_info \"Copying Python-specific files...\"\n  cp -rT \"\\$PYTHON_TEMPLATE_DIR/\" \"\\$TARGET_DIR/\"\n  mv \"\\${TARGET_DIR}/pyproject.toml_template\" \"\\${TARGET_DIR}/pyproject.toml\"\n  if [ -f \"\\${TARGET_DIR}/justfile_python_overlay\" ]; then\n    cat \"\\${TARGET_DIR}/justfile_python_overlay\" >> \"\\${TARGET_DIR}/Justfile\"\n    rm \"\\${TARGET_DIR}/justfile_python_overlay\"\n  fi\n  if [ -f \"\\${TARGET_DIR}/README_python.md\" ]; then\n    echo -e \"\\\\n\\\\n---\\\\n\" >> \"\\${TARGET_DIR}/README.md\"\n    cat \"\\${TARGET_DIR}/README_python.md\" >> \"\\${TARGET_DIR}/README.md\"\n    rm \"\\${TARGET_DIR}/README_python.md\"\n  fi\n  if [ -d \"\\${TARGET_DIR}/.vscode_template\" ]; then\n    mv \"\\${TARGET_DIR}/.vscode_template\" \"\\${TARGET_DIR}/.vscode\"\n  elif [ -f \"\\${TARGET_DIR}/settings.json_template\" ]; then\n    mkdir -p \"\\${TARGET_DIR}/.vscode\"\n    mv \"\\${TARGET_DIR}/settings.json_template\" \"\\${TARGET_DIR}/.vscode/settings.json\"\n  fi\n\n  PYTHON_PACKAGE_NAME=\\$(echo \"\\$PROJECT_NAME\" | sd \'-\' \'_\' | tr \'[:upper:]\' \'[:lower:]\')\n  mkdir -p \"\\${TARGET_DIR}/src/\\${PYTHON_PACKAGE_NAME}\"\n  touch \"\\${TARGET_DIR}/src/\\${PYTHON_PACKAGE_NAME}/__init__.py\"\n  echo \"print(\'Hello from \\${PYTHON_PACKAGE_NAME}\')\" > \"\\${TARGET_DIR}/src/\\${PYTHON_PACKAGE_NAME}/main.py\"\n  mkdir -p \"\\${TARGET_DIR}/tests\"\n  touch \"\\${TARGET_DIR}/tests/__init__.py\"\n  echo \"def test_example(): assert True\" > \"\\${TARGET_DIR}/tests/test_example.py\"\n\nelif [ \"\\$PROJECT_TYPE\" == \"rust\" ]; then\n  log_info \"Copying Rust-specific files...\"\n  cp -rT \"\\$RUST_TEMPLATE_DIR/\" \"\\$TARGET_DIR/\"\n  mv \"\\${TARGET_DIR}/Cargo.toml_template\" \"\\${TARGET_DIR}/Cargo.toml\"\n   if [ -f \"\\${TARGET_DIR}/justfile_rust_overlay\" ]; then\n    cat \"\\${TARGET_DIR}/justfile_rust_overlay\" >> \"\\${TARGET_DIR}/Justfile\"\n    rm \"\\${TARGET_DIR}/justfile_rust_overlay\"\n  fi\n  if [ -f \"\\${TARGET_DIR}/README_rust.md\" ]; then\n    echo -e \"\\\\n\\\\n---\\\\n\" >> \"\\${TARGET_DIR}/README.md\"\n    cat \"\\${TARGET_DIR}/README_rust.md\" >> \"\\${TARGET_DIR}/README.md\"\n    rm \"\\${TARGET_DIR}/README_rust.md\"\n  fi\n   if [ -d \"\\${TARGET_DIR}/.vscode_template\" ]; then\n    mv \"\\${TARGET_DIR}/.vscode_template\" \"\\${TARGET_DIR}/.vscode\"\n  elif [ -f \"\\${TARGET_DIR}/settings.json_template\" ]; then\n    mkdir -p \"\\${TARGET_DIR}/.vscode\"\n    mv \"\\${TARGET_DIR}/settings.json_template\" \"\\${TARGET_DIR}/.vscode/settings.json\"\n  fi\n  mkdir -p \"\\${TARGET_DIR}/src\"\n  echo \'fn main() { println!(\"Hello, world from {}!\", \"\'\"\\${PROJECT_NAME}\"\'\"); }\' > \"\\${TARGET_DIR}/src/main.rs\"\nfi\n\n# --- Placeholder Replacement (using sd) ---\nlog_info \"Replacing placeholders in copied files...\"\npushd \"\\$TARGET_DIR\" > /dev/null\n  find . -type f -not -path \'*/.git/*\' -not -name \'*.lock\' -print0 | while IFS= read -r -d \\\$'\0' file; do # Escaped $ here\n    if file -b --mime-type \"\\$file\" | grep -q text; then\n      sd \'{{PROJECT_NAME}}\' \"\\$PROJECT_NAME\" \"\\$file\" || true\n      sd \'{{PROJECT_TYPE}}\' \"\\$PROJECT_TYPE\" \"\\$file\" || true\n      PROJECT_NAME_SNAKE_CASE=\\$(echo \"\\$PROJECT_NAME\" | sd \'-\' \'_\' | tr \'[:upper:]\' \'[:lower:]\')\n      sd \'{{PROJECT_NAME_SNAKE_CASE}}\' \"\\$PROJECT_NAME_SNAKE_CASE\" \"\\$file\" || true\n      if [ \"\\$PROJECT_TYPE\" == \"python\" ]; then\n        sd \'{{PYTHON_VERSION}}\' \"\\$PYTHON_VERSION\" \"\\$file\" || true\n        PYTHON_VERSION_SHORT_NO_DOT=\\$(echo \"\\$PYTHON_VERSION\" | sd \'[.]\' \'\')\n        sd \'{{PYTHON_VERSION_SHORT_NO_DOT}}\' \"\\$PYTHON_VERSION_SHORT_NO_DOT\" \"\\$file\" || true\n        sd \'{{MANAGE_DEPS_WITH_UV2NIX}}\' \"\\$MANAGE_DEPS_WITH_UV2NIX\" \"\\$file\" || true\n        PYTHON_MAIN_MODULE_PATH=\"\\${PROJECT_NAME_SNAKE_CASE}.main\"\n        sd \'{{PYTHON_MAIN_MODULE_PATH}}\' \"\\$PYTHON_MAIN_MODULE_PATH\" \"\\$file\" || true\n      elif [ \"\\$PROJECT_TYPE\" == \"rust\" ]; then\n        sd \'{{RUST_EDITION}}\' \"\\$RUST_EDITION\" \"\\$file\" || true\n      fi\n    fi\n  done\npopd > /dev/null\n\n# --- Initialize Git Repository ---\nlog_info \"Initializing Git repository in \\${TARGET_DIR}...\"\npushd \"\\$TARGET_DIR\" > /dev/null\n  git init -b main\n  if [ -d \"example_scripts\" ]; then chmod +x example_scripts/* || true; fi\n  git add .\n  git commit -m \"Initial commit: scaffolded \\${PROJECT_TYPE} project \'\\${PROJECT_NAME}\' via template\"\npopd > /dev/null\n\n# --- Final Instructions ---\nlog_info \"✅ Project \'\\${PROJECT_NAME}\' initialized successfully in \'\\${TARGET_DIR}\'!\"\necho \"\"\necho \"Next steps:\"\necho \"  1. cd \\\\\"\\${TARGET_DIR}\\\\\"\"\necho \"  2. (If you use direnv and haven\'t already whitelisted the path) direnv allow\"\necho \"  3. Review devenv.nix, project_config.nix, and other generated files.\"\nif [ \"\\$PROJECT_TYPE\" == \"python\" ]; then\n  echo \"  4. For Python projects, run: devenv script setup-python\"\n  echo \"     (This creates a .venv and installs dependencies using uv)\"\n  if [ \"\\$MANAGE_DEPS_WITH_UV2NIX\" == \"true\" ]; then\n    echo \"  5. Optionally, to generate uv.nix: devenv script generate-uv-nix\"\n  fi\nfi\necho \"  6. Start developing! Try \'just --list\' or \'devenv script list\'.\"\n